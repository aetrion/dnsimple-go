// Package webhook provides the support for reading and parsing the events
// sent from DNSimple via webhook.
package webhook

import (
	"encoding/json"
	"errors"

	"github.com/dnsimple/dnsimple-go/dnsimple"
)

// Actor represents the entity that triggered the event. It can be either an user,
// a DNSimple support representative or the DNSimple system.
type Actor struct {
	ID     string `json:"id"`
	Entity string `json:"entity"`
	Pretty string `json:"pretty"`
}

// Account represents the account that this event is attached to.
type Account struct {
	dnsimple.Account

	// Display is a string that can be used as a display label
	// and it is sent in a webhook payload
	// It generally represent the name of the account.
	Display string `json:"display,omitempty"`

	// Identifier is a human-readable string identifier
	// and it is sent in a webhook payload
	// It generally represent the StringID or email of the account.
	Identifier string `json:"identifier,omitempty"`
}

// Event is an event generated in the DNSimple application.
type Event interface {
	GetEventName() string
	GetEventAccount() *Account
	GetEventActor() *Actor
	GetPayload() []byte
	parse([]byte) error
	getAbstractEvent() *AbstractEvent
	setEventHeader(header *eventHeader) error
}

type AbstractEvent struct {
	APIVersion   string
	RequestID    string
	EventName    string
	EventActor   *Actor
	EventAccount *Account
	eventPayload []byte

	// { data }

	// Auto is true if the event is an system-triggered automatic event.
	Auto bool `json:"auto"`
}

type eventName struct {
	Name string `json:"name"`
}

type eventHeader struct {
	APIVersion string   `json:"api_version"`
	RequestID  string   `json:"request_identifier"`
	Name       string   `json:"name"`
	Actor      *Actor   `json:"actor"`
	Account    *Account `json:"account"`
}

// GetAbstractEvent returns the underlying AbstractEvent.
func (e *AbstractEvent) getAbstractEvent() *AbstractEvent {
	return e
}

// GetEventName returns the event name as defined in the name field of the event.
func (e *AbstractEvent) GetEventName() string {
	return e.EventName
}

// GetEventAccount returns the account the event is associated to.
func (e *AbstractEvent) GetEventAccount() *Account {
	return e.EventAccount
}

// EventActor returns the actor the event was generated by.
func (e *AbstractEvent) GetEventActor() *Actor {
	return e.EventActor
}

// GetPayload returns the binary eventPayload the event was deserialized from.
func (e *AbstractEvent) GetPayload() []byte {
	return e.eventPayload
}

func (e *AbstractEvent) parse(payload []byte) error {
	e.eventPayload = payload
	return unmashalEvent(payload, e)
}

func (e *AbstractEvent) setEventHeader(header *eventHeader) error {
	e.APIVersion = header.APIVersion
	e.RequestID = header.RequestID
	e.EventName = header.Name
	e.EventActor = header.Actor
	e.EventAccount = header.Account
	return nil
}

// Parse takes an event payload and attempts to deserialize the payload into an event type
// that matches the event action in the payload. If no direct match is found, then a DefaultEvent is returned.
//
// Parse returns type is an Event interface. Therefore, you must perform typecasting
// to access any event-specific field.
func Parse(payload []byte) (Event, error) {
	action, err := ParseName(payload)
	if err != nil {
		return nil, err
	}

	return switchEvent(action, payload)
}

func ParseName(data []byte) (string, error) {
	name := &eventName{}
	err := json.Unmarshal(data, name)
	return name.Name, err
}

func unmashalEvent(data []byte, v interface{}) error {
	header := &eventHeader{}
	if err := json.Unmarshal(data, header); err != nil {
		return err
	}

	if err := json.Unmarshal(data, v); err != nil {
		return err
	}

	event, ok := v.(Event)
	if !ok {
		return errors.New("unable to typecast Event")
	}

	return event.setEventHeader(header)
}
